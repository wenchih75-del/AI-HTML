<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº’å‹•å¼åˆ†æ•¸æ•™å­¸ç³»çµ±</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f3f4f6; }
        canvas { touch-action: none; cursor: pointer; }
        .btn-mode { @apply px-4 py-2 rounded-lg font-bold transition-colors shadow-sm; }
        .btn-active { @apply bg-blue-600 text-white; }
        .btn-inactive { @apply bg-white text-gray-700 hover:bg-gray-100; }
        .panel-section { @apply bg-white p-4 rounded-xl shadow-sm mb-4 border border-gray-100; }
        .label-text { @apply block text-sm font-medium text-gray-700 mb-1; }
        input[type="number"] { @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500; }
        select { @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white; }
        
        /* åˆ†æ•¸é¡¯ç¤ºæ¨£å¼å„ªåŒ– */
        .fraction-display { display: inline-flex; align-items: center; font-family: 'Times New Roman', serif; }
        .fraction-whole { margin-right: 4px; font-size: 1.2em; font-weight: bold; }
        .fraction-part { display: flex; flex-direction: column; align-items: center; margin-left: 2px; }
        .fraction-num { border-bottom: 2px solid currentColor; padding-bottom: 1px; width: 100%; text-align: center; }
        .fraction-den { padding-top: 1px; width: 100%; text-align: center; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- è¼”åŠ©å‡½å¼ ---
        // å–å¾—æ–¹å¡ŠçŸ©é™£çš„æœ€ä½³æ’åˆ— (Rows, Cols)
        const getGridDimensions = (n) => {
            if (n <= 3) return [1, n];
            if (n === 4) return [2, 2];
            if (n === 6) return [2, 3];
            if (n === 8) return [2, 4];
            if (n === 9) return [3, 3];
            if (n === 10) return [2, 5];
            if (n === 12) return [3, 4];
            if (n > 12 && n % 5 === 0) return [n/5, 5];
            if (n > 12 && n % 4 === 0) return [n/4, 4];
            return [1, n]; // è³ªæ•¸æˆ–ç„¡æ³•æ•´é™¤æ™‚å‘ˆç¾é•·æ¢
        };

        const App = () => {
            // --- ç‹€æ…‹ç®¡ç† ---
            // æ¨¡å¼: 'teaching' | 'flashcard' | 'quiz'
            const [mode, setMode] = useState('teaching');
            
            // åˆ†æ•¸è¨­å®š
            const [numerator, setNumerator] = useState(3);
            const [denominator, setDenominator] = useState(8);
            const [fractionType, setFractionType] = useState('proper'); // 'proper', 'improper', 'mixed'
            const [visualType, setVisualType] = useState('continuous'); // 'continuous', 'discrete'
            const [shapeType, setShapeType] = useState('pie'); // 'pie', 'rect' (for continuous)
            
            // äº’å‹•èˆ‡å·¥å…·
            const [fillColor, setFillColor] = useState('#3b82f6');
            const [totalStudents, setTotalStudents] = useState(30);
            const [selectedStudent, setSelectedStudent] = useState(null);
            
            // è¨ˆæ™‚å™¨
            const [timerValue, setTimerValue] = useState(0);
            const [timerSetting, setTimerSetting] = useState(30);
            const [isTimerRunning, setIsTimerRunning] = useState(false);
            
            // äº’å‹•ç‹€æ…‹ (Set of strings: "shapeIndex-partIndex")
            const [userSelectedCells, setUserSelectedCells] = useState(new Set());
            
            // ç­”é¡Œæª¢æŸ¥
            const [quizResult, setQuizResult] = useState(null); // null, 'correct', 'wrong'

            // --- æ–°å¢ï¼šæŠ½èªæ¨¡å¼é¡¯ç¤ºç­”æ¡ˆ ---
            const [showFlashcardAnswer, setShowFlashcardAnswer] = useState(false);

            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const animationRef = useRef(null); // ç”¨æ–¼å„²å­˜æŠ½ç±¤å‹•ç•«çš„ interval ID
            
            // ç”¨ä¾†å„²å­˜é»æ“Šå€åŸŸçš„è³‡æ–™ï¼Œç”¨æ–¼äº’å‹•åˆ¤å®š
            const hitRegions = useRef([]);

            // --- é‚è¼¯è™•ç† ---

            // è¼”åŠ©ï¼šæ ¹æ“šæ•¸å€¼ç”¢ç”Ÿç·šæ€§çš„é¸å–å€å¡Š (ç”¨æ–¼è¼¸å…¥æ¡†æ”¹è®Šæ™‚)
            const updateSelectionLinear = (num, denom) => {
                const newSet = new Set();
                for (let i = 0; i < num; i++) {
                    const s = Math.floor(i / denom);
                    const p = i % denom;
                    newSet.add(`${s}-${p}`);
                }
                setUserSelectedCells(newSet);
            };

            // æ‰‹å‹•è¼¸å…¥åˆ†å­
            const handleNumeratorChange = (e) => {
                const val = Math.max(0, parseInt(e.target.value) || 0); // å…è¨± 0
                setNumerator(val);
                updateSelectionLinear(val, denominator);
            };

            // æ‰‹å‹•è¼¸å…¥åˆ†æ¯
            const handleDenominatorChange = (e) => {
                const val = Math.max(2, parseInt(e.target.value) || 2);
                setDenominator(val);
                // åˆ†æ¯æ”¹è®Šæ™‚ï¼Œä¿æŒåˆ†å­æ•¸å€¼ï¼Œé‡æ–°è¨ˆç®—ç·šæ€§æ’åˆ—
                updateSelectionLinear(numerator, val);
            };

            // é‡ç½®äº’å‹•å€
            const resetInteraction = useCallback(() => {
                setUserSelectedCells(new Set());
                setQuizResult(null);
                setShowFlashcardAnswer(false); // é‡ç½®ç­”æ¡ˆé¡¯ç¤º
            }, []);

            // ç”¢ç”Ÿéš¨æ©Ÿåˆ†æ•¸
            const generateRandomFraction = useCallback(() => {
                const newDenom = Math.floor(Math.random() * 11) + 2; // 2 ~ 12
                let newNum = 1;
                
                if (fractionType === 'proper') {
                    newNum = Math.floor(Math.random() * (newDenom - 1)) + 1;
                } else {
                    // å‡åˆ†æ•¸æˆ–å¸¶åˆ†æ•¸ï¼Œæœ€å¤§å€¼é™åˆ¶åœ¨ 3 ä»¥å…§
                    const maxVal = newDenom * 3; 
                    const minVal = newDenom + 1;
                    newNum = Math.floor(Math.random() * (maxVal - minVal)) + minVal;
                }
                
                setDenominator(newDenom);
                setNumerator(newNum);
                
                // é€™è£¡åªé‡ç½®äº’å‹•ï¼Œä¸éœ€è‡ªå‹•å¡«è‰²(æŠ½å¡«æ¨¡å¼) æˆ– åœ¨æŠ½èªæ¨¡å¼ä¸‹ç”± drawCanvas è™•ç†
                resetInteraction(); 
            }, [fractionType, resetInteraction]);

            // æŠ½ç±¤åŠŸèƒ½ (ä¿®æ”¹ç‚ºå¯é‡è¤‡è§¸ç™¼)
            const drawStudent = () => {
                // 1. å¦‚æœæœ‰æ­£åœ¨è·‘çš„å‹•ç•«ï¼Œå…ˆæ¸…é™¤
                if (animationRef.current) {
                    clearInterval(animationRef.current);
                }

                // 2. ç«‹å³é‡ç½®ç‹€æ…‹
                setShowFlashcardAnswer(false);
                setQuizResult(null);
                setIsTimerRunning(false); // æš«åœè¨ˆæ™‚ï¼Œç­‰å¾…å‹•ç•«çµæŸå¾Œé‡æ–°é–‹å§‹
                setTimerValue(0); // è¦–è¦ºæ­¸é›¶

                // 3. é–‹å§‹æŠ½ç±¤å‹•ç•«
                let count = 0;
                animationRef.current = setInterval(() => {
                    setSelectedStudent(Math.floor(Math.random() * totalStudents) + 1);
                    count++;
                    if (count > 10) {
                        clearInterval(animationRef.current);
                        animationRef.current = null;
                        
                        const final = Math.floor(Math.random() * totalStudents) + 1;
                        setSelectedStudent(final);
                        
                        // å‹•ç•«çµæŸï¼Œå‡ºé¡Œ
                        if (mode !== 'teaching') {
                            generateRandomFraction();
                        }
                        
                        // é‡æ–°é–‹å§‹è¨ˆæ™‚
                        startTimer();
                    }
                }, 50);
            };

            // è¨ˆæ™‚å™¨é‚è¼¯
            const startTimer = () => {
                setTimerValue(mode === 'quiz' ? 30 : timerSetting);
                setIsTimerRunning(true);
                setQuizResult(null);
            };

            useEffect(() => {
                let interval = null;
                if (isTimerRunning && timerValue > 0) {
                    interval = setInterval(() => {
                        setTimerValue(prev => prev - 1);
                    }, 1000);
                } else if (timerValue === 0) {
                    setIsTimerRunning(false);
                }
                return () => clearInterval(interval);
            }, [isTimerRunning, timerValue]);

            // æ¨¡å¼åˆ‡æ›æ™‚çš„åˆå§‹åŒ–
            useEffect(() => {
                resetInteraction();
                setQuizResult(null);
                setIsTimerRunning(false);
                setTimerValue(0);
                setSelectedStudent(null);
                
                // åˆ‡æ›æ¨¡å¼æ™‚ä¹Ÿè¦æ¸…é™¤å¯èƒ½å­˜åœ¨çš„å‹•ç•«
                if (animationRef.current) {
                    clearInterval(animationRef.current);
                    animationRef.current = null;
                }
                
                if (mode === 'teaching') {
                    // åˆ‡æ›åˆ°æ•™å­¸æ¨¡å¼æ™‚ï¼Œæ ¹æ“šç•¶å‰çš„åˆ†å­åˆ†æ¯åˆå§‹åŒ–é¡¯ç¤º
                    updateSelectionLinear(numerator, denominator);
                } else if (mode === 'quiz') {
                    setTimerSetting(30);
                }
            }, [mode, resetInteraction]); 

            // --- ç¹ªåœ–æ ¸å¿ƒ ---
            const drawCanvas = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;

                const ctx = canvas.getContext('2d');
                
                // è¨­å®šé«˜è§£æåº¦ Canvas
                const dpr = window.devicePixelRatio || 1;
                
                // --- ä¿®æ­£ Layout Thrashing ---
                // æ”¹ç”¨ clientWidth/clientHeight (ä¸å«é‚Šæ¡†)ï¼Œé¿å…å°ºå¯¸ç„¡é™å¢å¤§çš„è¿´åœˆ
                const width = container.clientWidth;
                const height = container.clientHeight;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                
                ctx.scale(dpr, dpr);
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;

                // å®šç¾©ä¸€å€‹å…§éƒ¨ä½¿ç”¨çš„ rect ç‰©ä»¶ï¼Œæ–¹ä¾¿å¾ŒçºŒé‚è¼¯ä½¿ç”¨
                const rect = { width, height };

                // æ¸…ç©ºç•«å¸ƒ
                ctx.clearRect(0, 0, width, height);
                hitRegions.current = []; // é‡ç½®é»æ“Šå€åŸŸ

                // è¨ˆç®—éœ€è¦å¹¾å€‹å®Œæ•´åœ–å½¢
                let totalShapes = Math.max(1, Math.ceil(numerator / denominator));
                
                if (mode !== 'teaching' && numerator > denominator) {
                     totalShapes = Math.ceil(numerator / denominator);
                }
                
                // --- ç‰ˆé¢é…ç½®è¨ˆç®— (ä¿®æ­£è² æ•¸å¯¬åº¦å•é¡Œ) ---
                const padding = 20;
                const availableW = Math.max(0, width - padding * 2);
                const availableH = Math.max(0, height - padding * 2);
                let shapeGap = 20;

                // è‹¥ç¸½é–“è·è¶…éå¯ç”¨å¯¬åº¦ï¼Œç¸®å°é–“è·
                if ((totalShapes - 1) * shapeGap > availableW / 2) {
                     // è®“é–“è·è®Šå°ï¼Œç”šè‡³ç‚º0
                     shapeGap = Math.max(0, (availableW * 0.1) / Math.max(1, totalShapes - 1));
                }
                
                // æ±ºå®šå–®ä¸€åœ–å½¢çš„å¤§å°
                let maxShapeWidth = (availableW - (totalShapes - 1) * shapeGap) / totalShapes;
                
                // ç¢ºä¿éè² 
                maxShapeWidth = Math.max(0, maxShapeWidth);
                
                const maxShapeHeight = availableH;
                
                // å–è¼ƒå°è€…ä½œç‚ºåŸºæº–å°ºå¯¸
                let shapeSize = Math.min(maxShapeWidth, maxShapeHeight);
                if (visualType === 'continuous' && shapeType === 'rect') {
                    shapeSize = Math.min(maxShapeWidth, maxShapeHeight * 0.8); 
                }
                
                // ç¢ºä¿ shapeSize ä¸ç‚ºè² 
                shapeSize = Math.max(0, shapeSize);

                // é–‹å§‹ä½ç½® (ç½®ä¸­)
                const totalContentWidth = totalShapes * shapeSize + (totalShapes - 1) * shapeGap;
                let startX = (width - totalContentWidth) / 2;
                const startY = (height - shapeSize) / 2;

                // ç¹ªè£½è¿´åœˆ
                for (let i = 0; i < totalShapes; i++) {
                    const currentX = startX + i * (shapeSize + shapeGap);
                    const currentY = startY;

                    drawSingleShape(ctx, currentX, currentY, shapeSize, i);
                }

            }, [numerator, denominator, visualType, shapeType, mode, userSelectedCells, fillColor, fractionType]);

            // ç¹ªè£½å–®å€‹åœ–å½¢ (å–®ä½é‡)
            const drawSingleShape = (ctx, x, y, size, shapeIndex) => {
                const cx = x + size / 2;
                const cy = y + size / 2;
                // ä¿®æ­£: ç¢ºä¿åŠå¾‘éè² æ•¸ï¼Œé¿å… IndexSizeError
                const r = Math.max(0, (size / 2) * 0.9); 

                const getIsFilled = (partIndex) => {
                    const globalIndex = shapeIndex * denominator + partIndex;
                    if (mode === 'flashcard') {
                        return globalIndex < numerator;
                    } else {
                        return userSelectedCells.has(`${shapeIndex}-${partIndex}`);
                    }
                };

                // --- é€£çºŒé‡ï¼šåœ“é¤…åœ– ---
                if (visualType === 'continuous' && shapeType === 'pie') {
                    for (let j = 0; j < denominator; j++) {
                        const startAngle = (Math.PI * 2 * j) / denominator - Math.PI / 2;
                        const endAngle = (Math.PI * 2 * (j + 1)) / denominator - Math.PI / 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        // ç¢ºä¿ r æœ‰æ•ˆ
                        if (r > 0) {
                            ctx.arc(cx, cy, r, startAngle, endAngle);
                        }
                        ctx.closePath();

                        const filled = getIsFilled(j);
                        ctx.fillStyle = filled ? fillColor : '#ffffff';
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        hitRegions.current.push({
                            type: 'pie',
                            cx, cy, r,
                            startAngle, endAngle,
                            shapeIndex: shapeIndex,
                            partIndex: j
                        });
                    }
                }
                
                // --- é€£çºŒé‡ï¼šçŸ©é™£æ–¹å¡Š ---
                else if (visualType === 'continuous' && shapeType === 'rect') {
                    const [rows, cols] = getGridDimensions(denominator);
                    const cellW = size / cols;
                    const cellH = size / rows; 

                    // èª¿æ•´èµ·å§‹ä½ç½®è®“çŸ©é™£ç½®ä¸­
                    const matrixH = cellH * rows;
                    const matrixW = cellW * cols;
                    const matrixX = x + (size - matrixW) / 2;
                    const matrixY = y + (size - matrixH) / 2;

                    for (let j = 0; j < denominator; j++) {
                        const row = Math.floor(j / cols);
                        const col = j % cols;
                        const cellX = matrixX + col * cellW;
                        const cellY = matrixY + row * cellH;

                        const filled = getIsFilled(j);

                        ctx.fillStyle = filled ? fillColor : '#ffffff';
                        ctx.fillRect(cellX, cellY, cellW, cellH);
                        ctx.strokeRect(cellX, cellY, cellW, cellH);

                        hitRegions.current.push({
                            type: 'rect',
                            x: cellX, y: cellY, w: cellW, h: cellH,
                            shapeIndex: shapeIndex,
                            partIndex: j
                        });
                    }
                }

                // --- é›¢æ•£é‡ï¼šè¢‹å­èˆ‡ç‰©ä»¶ ---
                else if (visualType === 'discrete') {
                    ctx.save();
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, size, size); // æ–¹å½¢è¢‹å­
                    ctx.restore();

                    const [rows, cols] = getGridDimensions(denominator);
                    const cellW = size / cols;
                    const cellH = size / rows;
                    const itemRadius = Math.max(0, Math.min(cellW, cellH) * 0.35); // ç¢ºä¿åŠå¾‘éè² 

                     for (let j = 0; j < denominator; j++) {
                        const row = Math.floor(j / cols);
                        const col = j % cols;
                        const itemCX = x + col * cellW + cellW / 2;
                        const itemCY = y + row * cellH + cellH / 2;

                        const filled = getIsFilled(j);

                        ctx.beginPath();
                        if (itemRadius > 0) {
                            ctx.arc(itemCX, itemCY, itemRadius, 0, Math.PI * 2);
                        }
                        
                        if (filled) {
                            ctx.fillStyle = fillColor;
                            ctx.fill();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        } else {
                            ctx.fillStyle = 'rgba(200, 200, 200, 0.2)';
                            ctx.fill();
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }

                        hitRegions.current.push({
                            type: 'circle',
                            cx: itemCX, cy: itemCY, r: itemRadius * 1.5,
                            shapeIndex: shapeIndex,
                            partIndex: j
                        });
                    }
                }
            };

            // ç›£è½ä¾è³´è®Šæ•¸ä»¥é‡ç¹ª
            useEffect(() => {
                drawCanvas();
            }, [drawCanvas]);
            
            // è¦–çª—å¤§å°æ”¹è®Šé‡ç¹ª
            useEffect(() => {
                window.addEventListener('resize', drawCanvas);
                return () => window.removeEventListener('resize', drawCanvas);
            }, [drawCanvas]);


            // --- é»æ“Šäº’å‹•è™•ç† ---
            const handleCanvasClick = (e) => {
                if (mode === 'flashcard') return; // æŠ½èªæ¨¡å¼ä¸å¯é»

                const rect = canvasRef.current.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                let clickedId = null;

                for (let i = hitRegions.current.length - 1; i >= 0; i--) {
                    const region = hitRegions.current[i];
                    let isHit = false;

                    if (region.type === 'rect') {
                         if (clickX >= region.x && clickX <= region.x + region.w &&
                             clickY >= region.y && clickY <= region.y + region.h) {
                             isHit = true;
                         }
                    } else if (region.type === 'circle') {
                        const dist = Math.sqrt((clickX - region.cx)**2 + (clickY - region.cy)**2);
                        if (dist <= region.r) isHit = true;
                    } else if (region.type === 'pie') {
                        const dist = Math.sqrt((clickX - region.cx)**2 + (clickY - region.cy)**2);
                        if (dist <= region.r) {
                            let angle = Math.atan2(clickY - region.cy, clickX - region.cx);
                            let relativeAngle = angle + Math.PI / 2; 
                            if (relativeAngle < 0) relativeAngle += Math.PI * 2;
                            
                            const unitAngle = (Math.PI * 2) / denominator;
                            const calculatedIndex = Math.floor(relativeAngle / unitAngle);
                            
                            if (calculatedIndex === region.partIndex) {
                                isHit = true;
                            }
                        }
                    }

                    if (isHit) {
                        clickedId = `${region.shapeIndex}-${region.partIndex}`;
                        break;
                    }
                }

                if (clickedId) {
                    const newSet = new Set(userSelectedCells);
                    if (newSet.has(clickedId)) {
                        newSet.delete(clickedId);
                    } else {
                        newSet.add(clickedId);
                    }
                    setUserSelectedCells(newSet);

                    // --- é—œéµä¿®æ”¹ï¼šæ•™å­¸æ¨¡å¼ä¸‹ï¼Œé»æ“ŠåŒæ­¥æ›´æ–°ã€Œåˆ†å­ã€ ---
                    if (mode === 'teaching') {
                        setNumerator(newSet.size);
                    }
                }
            };

            // æª¢æŸ¥ç­”æ¡ˆ (Quiz Mode)
            const checkAnswer = () => {
                const clickedCount = userSelectedCells.size;
                if (clickedCount === numerator) {
                    setQuizResult('correct');
                } else {
                    setQuizResult('wrong');
                }
            };

            // åŒ¯å‡º PNG
            const exportPNG = () => {
                const canvas = canvasRef.current;
                const link = document.createElement('a');
                link.download = `fraction-${numerator}-over-${denominator}.png`;
                link.href = canvas.toDataURL();
                link.click();
            };

            // é¡¯ç¤ºæ–‡å­—é‚è¼¯ï¼šå„ªåŒ–åˆ†æ•¸é¡¯ç¤ºæ ¼å¼
            const getFractionText = () => {
                // ç”¨æ–¼ Header é¡¯ç¤º
                if (fractionType === 'mixed') {
                    const whole = Math.floor(numerator / denominator);
                    const remainder = numerator % denominator;
                    if (remainder === 0) return <span className="fraction-display"><span className="fraction-whole">{numerator / denominator}</span></span>;
                    return (
                        <span className="fraction-display">
                            <span className="fraction-whole">{whole}</span>
                            <span className="fraction-part">
                                <span className="fraction-num">{remainder}</span>
                                <span className="fraction-den">{denominator}</span>
                            </span>
                        </span>
                    );
                }
                return (
                    <span className="fraction-display">
                        <span className="fraction-part">
                            <span className="fraction-num">{numerator}</span>
                            <span className="fraction-den">{denominator}</span>
                        </span>
                    </span>
                );
            };

            return (
                <div className="flex flex-col md:flex-row h-screen p-4 gap-4 max-w-7xl mx-auto">
                    {/* å·¦æ¬„ï¼šé¡¯ç¤ºèˆ‡äº’å‹•å€ */}
                    <div className="flex-1 flex flex-col bg-white rounded-2xl shadow-lg border border-gray-200 overflow-hidden relative">
                        {/* æ¨™é¡Œ/ç‹€æ…‹åˆ— */}
                        <div className="bg-gray-50 p-3 border-b border-gray-200 flex justify-between items-center h-16">
                            <h2 className="font-bold text-gray-700 text-lg flex items-center gap-2">
                                <span className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full whitespace-nowrap">
                                    {mode === 'teaching' ? 'æ•™å­¸æ¨¡å¼' : mode === 'flashcard' ? 'æŠ½èªæ¨¡å¼' : 'æŠ½å¡«æ¨¡å¼'}
                                </span>
                                {mode === 'teaching' && <span className="flex items-center gap-2">åˆ†æ•¸å±•ç¤ºï¼š{getFractionText()}</span>}
                                {mode === 'flashcard' && (
                                    <span className="flex items-center gap-2">
                                        è«‹å›ç­”ï¼šåœ–ä¸­æœ‰å¤šå°‘ï¼Ÿ
                                        {/* ç­”æ¡ˆå…¬å¸ƒå€ */}
                                        {showFlashcardAnswer && (
                                            <span className="ml-2 animate-bounce bg-teal-50 text-teal-700 px-3 py-1 rounded-lg border border-teal-200 shadow-sm">
                                                {getFractionText()}
                                            </span>
                                        )}
                                    </span>
                                )}
                                {mode === 'quiz' && <span className="flex items-center gap-2">è«‹ç•«å‡ºï¼š{getFractionText()}</span>}
                            </h2>
                            <div className="flex items-center gap-4">
                                {selectedStudent && (
                                    <div className="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full font-bold whitespace-nowrap">
                                        åº§è™Ÿ: {selectedStudent}
                                    </div>
                                )}
                                {timerValue > 0 && (
                                    <div className={`font-mono font-bold text-xl ${timerValue <= 5 ? 'text-red-600 animate-pulse' : 'text-gray-700'}`}>
                                        {timerValue}s
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* ç•«å¸ƒå€ */}
                        <div ref={containerRef} className="flex-1 relative bg-gray-50 m-2 rounded-xl border-2 border-dashed border-gray-200 flex items-center justify-center">
                            <canvas 
                                ref={canvasRef} 
                                onClick={handleCanvasClick}
                                className="block max-w-full max-h-full"
                            />
                            
                            {/* ç­”é¡Œå›é¥‹è¦†è“‹å±¤ */}
                            {quizResult && (
                                <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-30 rounded-xl pointer-events-none">
                                    <div className={`px-8 py-4 rounded-2xl text-4xl font-bold text-white shadow-xl transform scale-110 transition-transform ${quizResult === 'correct' ? 'bg-green-500' : 'bg-red-500'}`}>
                                        {quizResult === 'correct' ? 'ç­”å°äº†ï¼ğŸ‰' : 'å†è©¦è©¦çœ‹ï¼ğŸ’ª'}
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* åº•éƒ¨å·¥å…·åˆ— (Export) */}
                        <div className="p-3 bg-white border-t border-gray-100 flex justify-end">
                            <button onClick={exportPNG} className="flex items-center text-gray-500 hover:text-gray-800 text-sm font-medium">
                                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                                ä¸‹è¼‰åœ–ç‰‡ (PNG)
                            </button>
                        </div>
                    </div>

                    {/* å³æ¬„ï¼šæ§åˆ¶é¢æ¿ */}
                    <div className="w-full md:w-80 flex flex-col gap-4 overflow-y-auto">
                        
                        {/* 1. æ¨¡å¼åˆ‡æ› */}
                        <div className="panel-section flex gap-1 p-1 bg-gray-100 rounded-lg">
                            {['teaching', 'flashcard', 'quiz'].map(m => (
                                <button
                                    key={m}
                                    onClick={() => setMode(m)}
                                    className={`flex-1 py-2 rounded-md text-sm ${mode === m ? 'bg-white text-blue-700 shadow font-bold' : 'text-gray-500 hover:text-gray-700'}`}
                                >
                                    {m === 'teaching' ? 'æ•™å­¸' : m === 'flashcard' ? 'æŠ½èª' : 'æŠ½å¡«'}
                                </button>
                            ))}
                        </div>

                        {/* 2. åƒæ•¸è¨­å®š */}
                        <div className="panel-section">
                            <h3 className="font-bold text-gray-800 mb-3 border-b pb-2">åƒæ•¸è¨­å®š</h3>
                            
                            <div className="mb-3">
                                <label className="label-text">åˆ†æ•¸é¡å‹</label>
                                <div className="flex gap-2">
                                    <label className="flex items-center"><input type="radio" name="ftype" checked={fractionType === 'proper'} onChange={() => setFractionType('proper')} className="mr-1"/>çœŸåˆ†æ•¸</label>
                                    <label className="flex items-center"><input type="radio" name="ftype" checked={fractionType === 'improper'} onChange={() => setFractionType('improper')} className="mr-1"/>å‡åˆ†æ•¸</label>
                                    <label className="flex items-center"><input type="radio" name="ftype" checked={fractionType === 'mixed'} onChange={() => setFractionType('mixed')} className="mr-1"/>å¸¶åˆ†æ•¸</label>
                                </div>
                            </div>

                            <div className="mb-3">
                                <label className="label-text">å‘ˆç¾å‹æ…‹</label>
                                <select value={visualType} onChange={(e) => setVisualType(e.target.value)}>
                                    <option value="continuous">é€£çºŒé‡ (Continuous)</option>
                                    <option value="discrete">é›¢æ•£é‡ (Discrete)</option>
                                </select>
                            </div>

                             {visualType === 'continuous' && (
                                <div className="mb-3">
                                    <label className="label-text">åœ–å½¢å½¢ç‹€</label>
                                    <div className="flex gap-2 bg-gray-100 p-1 rounded">
                                         <button onClick={() => setShapeType('pie')} className={`flex-1 py-1 text-xs rounded ${shapeType === 'pie' ? 'bg-white shadow' : ''}`}>åœ“å½¢</button>
                                         <button onClick={() => setShapeType('rect')} className={`flex-1 py-1 text-xs rounded ${shapeType === 'rect' ? 'bg-white shadow' : ''}`}>æ–¹å¡Š/çŸ©é™£</button>
                                    </div>
                                </div>
                            )}

                            {/* åªæœ‰æ•™å­¸æ¨¡å¼å¯ä»¥æ‰‹å‹•è¼¸å…¥æ•¸å€¼ */}
                            {mode === 'teaching' && (
                                <div className="grid grid-cols-2 gap-2 mt-2">
                                    <div>
                                        <label className="label-text">åˆ†å­</label>
                                        <input 
                                            type="number" 
                                            value={numerator} 
                                            onChange={handleNumeratorChange} // ç¶å®šæ–°è™•ç†å‡½å¼
                                        />
                                    </div>
                                    <div>
                                        <label className="label-text">åˆ†æ¯</label>
                                        <input 
                                            type="number" 
                                            value={denominator} 
                                            onChange={handleDenominatorChange} // ç¶å®šæ–°è™•ç†å‡½å¼
                                        />
                                    </div>
                                </div>
                            )}
                            
                            <div className="mt-3">
                                <label className="label-text">å¡«æ»¿é¡è‰²</label>
                                <div className="flex gap-2">
                                    <input type="color" value={fillColor} onChange={(e) => setFillColor(e.target.value)} className="h-8 w-12 p-0 border-0 rounded overflow-hidden" />
                                    <span className="text-sm text-gray-500 self-center">é»æ“Šé¸æ“‡</span>
                                </div>
                            </div>
                        </div>

                        {/* 3. åŠŸèƒ½æ“ä½œå€ */}
                        <div className="panel-section bg-blue-50 border-blue-100">
                            <h3 className="font-bold text-blue-800 mb-3 border-b border-blue-200 pb-2">èª²å ‚å·¥å…·</h3>
                            
                            {/* åº§è™Ÿè¨­å®š */}
                            <div className="flex items-center gap-2 mb-4">
                                <span className="text-sm text-gray-600">å…¨ç­äººæ•¸:</span>
                                <input type="number" value={totalStudents} onChange={(e) => setTotalStudents(parseInt(e.target.value))} className="w-16 h-8 text-center text-sm" />
                            </div>

                            {/* å€’æ•¸æ™‚é–“è¨­å®š (æŠ½èªæ¨¡å¼) */}
                            {mode === 'flashcard' && (
                                <div className="mb-4">
                                    <label className="label-text">å€’æ•¸ç§’æ•¸</label>
                                    <div className="flex justify-between gap-1">
                                        {[10, 15, 20, 25, 30].map(s => (
                                            <button 
                                                key={s} 
                                                onClick={() => setTimerSetting(s)}
                                                className={`px-2 py-1 text-xs rounded ${timerSetting === s ? 'bg-blue-600 text-white' : 'bg-white border'}`}
                                            >
                                                {s}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* éš¨æ©ŸæŠ½ç±¤æŒ‰éˆ• */}
                            <button 
                                onClick={drawStudent}
                                className="w-full py-3 rounded-lg font-bold text-white shadow-md mb-3 flex justify-center items-center gap-2 bg-indigo-600 hover:bg-indigo-700"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                                éš¨æ©ŸæŠ½ç±¤ {mode !== 'teaching' && '& å‡ºé¡Œ'}
                            </button>

                            {/* æŠ½èªæ¨¡å¼å°ˆç”¨ï¼šå…¬å¸ƒç­”æ¡ˆæŒ‰éˆ• */}
                            {mode === 'flashcard' && (
                                <button 
                                    onClick={() => setShowFlashcardAnswer(!showFlashcardAnswer)}
                                    className={`w-full py-3 rounded-lg font-bold shadow-md mb-2 flex justify-center items-center gap-2 transition-all ${showFlashcardAnswer ? 'bg-teal-700 text-white' : 'bg-teal-500 hover:bg-teal-600 text-white'}`}
                                >
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                                    {showFlashcardAnswer ? 'éš±è—ç­”æ¡ˆ' : 'å…¬å¸ƒç­”æ¡ˆ'}
                                </button>
                            )}

                            {/* æŠ½å¡«æ¨¡å¼å°ˆç”¨ï¼šæª¢æŸ¥ç­”æ¡ˆ */}
                            {mode === 'quiz' && (
                                <button 
                                    onClick={checkAnswer}
                                    className="w-full py-3 bg-green-600 text-white rounded-lg font-bold shadow-md hover:bg-green-700 flex justify-center items-center gap-2"
                                >
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                    ç¢ºå®š / æª¢æŸ¥ç­”æ¡ˆ
                                </button>
                            )}
                            
                            {/* é‡ç½® */}
                            <button 
                                onClick={resetInteraction}
                                className="w-full mt-2 py-2 text-gray-500 hover:bg-gray-200 rounded text-sm"
                            >
                                æ¸…é™¤ç•«å¸ƒ
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
